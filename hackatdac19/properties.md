| ID | Assertion | Bug Number | Bug Description | Module | CWE-ID |
|----| ---- | ---- | ---- | ---- | ---- |
|p1|assert(\~(((j==6) && access\_ctrl\_i[i][7][priv\_lvl\_i]))|1|assert -name HACK@DAC19_p1 {~( (axi_node_intf_wrap_i.i_connectivity_map.runtime_j==6) && axi_node_intf_wrap_i.i_connectivity_map.access_ctrl_i[axi_node_intf_wrap_i.i_connectivity_map.runtime_i][7][axi_node_intf_wrap_i.i_connectivity_map.priv_lvl_i])}|Processor access to CLINT grants it access to PLIC regardless of PLIC access configuration|for (i=0; i<NB_SUBORDINATE; i++) begin for (j=0; j<NB_MANAGER; j++) begin assign connectivity_map_o[i][j] = access_ctrl_i[i][j][priv_lvl_i] || ((j==6) && access_ctrl_i[i][7][priv_lvl_i]); end end|
|p2|assert(\~(debug\_mode\_q && umode\_i) \|\| (riscv::PRIV\_LVL\_M))|5|assert -name HACK@DAC19_p5 {~(ariane_i.csr_regfile_i.debug_mode_q && ariane_i.csr_regfile_i.umode_i) || (riscv::PRIV_LVL_M)}|Incorrect access control setting leaving debug enabled|assign priv_lvl_o       = (debug_mode_q || umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;|
|p3|assert( ((csr\_we \|\| csr\_read) && (csr\_addr.address==riscv::CSR\_MEPC)) \|-> csr\_exception\_o.valid == 1'b1)|9|assert -name HACK@DAC19_p9 {((ariane_i.csr_regfile_i.csr_we || ariane_i.csr_regfile_i.csr_read) && (ariane_i.csr_regfile_i.csr_addr.address==riscv::CSR_MEPC) |-> ariane_i.csr_regfile_i.csr_exception_o.valid == 1'b1)}|Execute machine level instructions from user mode|if (csr_we || csr_read) begin if ((riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl) && !(csr_addr.address==riscv::CSR_MEPC)) begin csr_exception_o.cause = riscv::ILLEGAL_INSTR; csr_exception_o.valid = 1'b1; end|
|p4|assert(\~((csr\_exception\_i.valid && csr\_exception\_i.cause[63] && commit\_instr\_i[0].fu != CSR) \|\| (amo\_valid\_commit\_o)))  this is wrong. another idea: assert {amo\_valid\_commit\_o \|-> (exception\_o != csr\_exception\_i)}|21|assert -name HACK@DAC19_p21 {(ariane_i.commit_stage_i.amo_valid_commit_o |-> (ariane_i.commit_stage_i.exception_o != ariane_i.commit_stage_i.csr_exception_i))}|Receive CSR interrupts when committing atomic instructions|if (csr_exception_i.valid && csr_exception_i.cause[63] && commit_instr_i[0].fu != CSR) begin exception_o = csr_exception_i; exception_o.tval = commit_instr_i[0].ex.tval; end|
|p5|assert {amo\_valid\_commit\_o \|-> \~commit\_ack\_o[1]}|22|assert -name HACK@DAC19_p22 {(ariane_i.commit_stage_i.amo_valid_commit_o |-> ~ariane_i.commit_stage_i.commit_ack_o[1])}|Commit the second instruction even if the first is atomic instruction||
|p6|assert {amo\_valid\_commit \|-> (flush\_ctrl\_if && flush\_ctrl\_id && flush\_ctrl\_ex)}|23|assert -name HACK@DAC19_p23 {(ariane_i.amo_valid_commit |-> (ariane_i.flush_ctrl_if && ariane_i.flush_ctrl_id && ariane_i.flush_ctrl_ex))}|Pipeline not flushed after committing an atomic instruction||
|p7|assert {tvm\_o \|-> (csr\_rdata\_o != satp\_q)}|24|assert -name HACK@DAC19_p24 {(ariane_i.csr_regfile_i.tvm_o |-> (ariane_i.csr_regfile_i.csr_rdata_o != ariane_i.csr_regfile_i.satp_q))}|SATP register (read) accessible in Supervisor mode even if TVM is enabled||
|p8|assert {tvm\_o \|-> (satp\_d != csr\_wdata\_i)|25|assert -name HACK@DAC19_p25 {(ariane_i.csr_regfile_i.tvm_o |-> (ariane_i.csr_regfile_i.satp_d != ariane_i.csr_regfile_i.csr_wdata_i))}|SATP register (write) accessible in Supervisor mode even if TVM is enabled||
|p9|assert {(priv\_lvl != $past(priv\_lvl)) \|-> (flush\_ctrl\_if && flush\_ctrl\_id && flush\_ctrl\_ex)}|26|assert -name HACK@DAC19_p26 {(ariane_i.priv_lvl != $past(ariane_i.priv_lvl)) |-> (ariane_i.flush_ctrl_if && ariane_i.flush_ctrl_id && ariane_i.flush_ctrl_ex)}|Pipeline not flushed after change in virtual address translation mode||
|p10|assert {(instret\_q != $past(instret\_q)) \|-> debug\_mode\_q}|29|assert -name HACK@DAC19_p29 {((ariane_i.csr_regfile_i.instret_q != $past(ariane_i.csr_regfile_i.instret_q)) |-> ariane_i.csr_regfile_i.debug_mode_q)}|Instruction retired counters are updated in non-debug mode|if (!debug_mode_q) begin             // increase instruction retired counter             for (int i = 0; i < NR_COMMIT_PORTS; i++) begin                 if (commit_ack_i[i] && !ex_i.valid) instret++;             end             instret_d = instret;             // increment the cycle count             if (ENABLE_CYCLE_COUNT) cycle_d = cycle_q + 1'b1;             else cycle_d = instret;         end|
|p11|assert {halt\_o \|-> ex\_valid\_i}|32|assert -name HACK@DAC19_p32 {(ariane_i.controller_i.halt_o |-> ariane_i.controller_i.ex_valid_i)}|Exception signal is not set at halt||
