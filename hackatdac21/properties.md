| ID | Assertion | Bug Number | Bug Description | CWE-ID |
|----| ---- | ---- | ---- | ---- |
|p1|assert(\~trst\_ni \|-> pass\_check == 1'b0) |1|assert -name HACK@DAC21_p1 {(~dmi_jtag_i.trst_ni |-> dmi_jtag_i.pass_check == 1'b0)}|            PassChkValid: begin                if(hashValid) begin                      if(exp_hash == pass_hash) begin                          pass_check = 1'b1;                     end else begin                         pass_check = 1'b0;                     end                     state_d = Idle;                 end else begin                    state_d = PassChkValid;                 end               end|
|p2|assert (state\_q == IDLE && state\_d == WRITE \|-> pass\_check == 1'b1)|2|assert -name HACK@DAC21_p2 {(dmi_jtag_i.state_q == dmi_jtag_i.Idle && dmi_jtag_i.state_d == dmi_jtag_i.Write |-> dmi_jtag_i.pass_check == 1'b1)}|       case (state_q)             Idle: begin                 // make sure that no error is sticky                 if (dmi_access && update_dr && (error_q == DMINoError)) begin                     // save address and value                     address_d = dmi.address;                     data_d = dmi.data;                     if ( (dm::dtm_op_e'(dmi.op) == dm::DTM_READ) && (pass_check | ~we_flag == 1) ) begin                         state_d = Read;                     end else if ( (dm::dtm_op_e'(dmi.op) == dm::DTM_WRITE) && (pass_check == 1) ) begin                         state_d = Write;                     end else if (dm::dtm_op_e'(dmi.op) == dm::DTM_PASS) begin                         state_d = Write;                         pass_mode = 1'b1;                     end                      // else this is a nop and we can stay here                 end             end|
|p3|assert(\~(debug\_mode\_q && umode\_i) \|\| (riscv::PRIV\_LVL\_M))|7|assert -name HACK@DAC21_p7 {(~(ariane_i.csr_regfile_i.debug_mode_q) || (riscv::PRIV_LVL_M))}|assign priv_lvl_o       = (debug_mode_q || umode_i) ? riscv::PRIV_LVL_M : priv_lvl_q;|
|p4|assert(count - 1 == $next(count)) or something ** draft|14|assert -name HACK@DAC21_p14 {( (aes0_wrapper_i.aes.uut.validCounter - 1) == $next(aes0_wrapper_i.aes.uut.validCounter))}|always @ (posedge clk)     begin         if(start_posedge)             begin                 s0 <= state ^ key[191:64];                 k0 <= key;                 validCounter <= 25;             end         else if(~out_valid)             begin                 validCounter <= validCounter - 1;             end     end|
|p5|assert((csr\_we && csr.addr.address == riscv::CSR\_SIE) -> mie\_d == (mie\_q & \~mideleg\_q) \| (csr\_wdata & mideleg\_q))|18|assert -name HACK@DAC21_p18 {(ariane_i.csr_regfile_i.csr_we && ariane_i.csr_regfile_i.csr_addr.address == riscv::CSR_SIE) -> ariane_i.csr_regfile_i.mie_d == (ariane_i.csr_regfile_i.mie_q & ~ariane_i.csr_regfile_i.mideleg_q) | (ariane_i.csr_regfile_i.csr_wdata & ariane_i.csr_regfile_i.mideleg_q)}|riscv::CSR_SIE: begin // the mideleg makes sure only delegate-able register //(and therefore also only implemented registers) are written mie_d = (mie_q & ~mideleg_q) | (csr_wdata & mideleg_q) | utval_q; end|
|p6|assert(pass\_mode \|-> pass\_data == data\_d)|30|assert -name HACK@DAC21_p30 {((dmi_jtag_i.pass_mode) |-> (dmi_jtag_i.pass_data == dmi_jtag_i.data_d))}|logic [31:0] data_d, data_q logic [512-1:0] pass_data; ... Write: begin ... if (pass_mode) begin pass_data = { {60{8'h00}}, data_d}; state_d = PassChk; pass_mode = 1'b0; ... end ...|
|p7|assert\~(\~(rst\_ni && \~jtag\_unlock && \~rst\_9) \|-> (reglk\_mem == 'h0))|35|assert -name HACK@DAC21_p35 {~(reglk_wrapper_i.rst_ni && ~reglk_wrapper_i.jtag_unlock && ~reglk_wrapper_i.rst_9) |-> (reglk_wrapper_i.reglk_mem == 'h0)}|    begin         if(~(rst_ni && ~jtag_unlock && ~rst_9))             begin               for (j=0; j < 6; j=j+1) begin                 reglk_mem[j] <= 'h0;               end             end|
|p8|assert (sha256\_ctrl\_reg == IGNORE && ignore\_input\_reg \|-> data == 0)|36|assert -name HACK@DAC21_p36 {((sha256_wrapper_i.sha256.sha256_ctrl_reg == sha256_wrapper_i.sha256.CTRL_IGNORE && sha256_wrapper_i.sha256.ignore_input_reg) |-> (sha256_wrapper_i.data == 0))}|// Implement SHA256 I/O memory map interface // Write side always @(posedge clk_i) begin if(~(rst_ni && ~rst_3)) begin startHash <= 0; newMessage <= 0; data[0] <= 0; data[1] <= 0; data[2] <= 0; ... data[14] <= 0; data[15] <= 0; ...|
|p9|assert(ct\_valid \|-> ((p\_c[0] == 0) && (p\_c[1] == 0) && (p\_c[2] == 0) && (p\_c[3] == 0)) |39|assert -name HACK@DAC21_p39 {(aes0_wrapper_i.ct_valid |-> ((aes0_wrapper_i.p_c[0] == 0) && (aes0_wrapper_i.p_c[1] == 0) && (aes0_wrapper_i.p_c[2] == 0) && (aes0_wrapper_i.p_c[3] == 0)))}|else if(en && we) case(address[8:3]) 0: start <= reglk_ctrl_i[1] ? start : wdata[0]; 1: p_c[3] <= reglk_ctrl_i[3] ? p_c[3] : wdata[31:0]; 2: p_c[2] <= reglk_ctrl_i[3] ? p_c[2] : wdata[31:0]; 3: p_c[1] <= reglk_ctrl_i[3] ? p_c[1] : wdata[31:0]; 4: p_c[0] <= reglk_ctrl_i[3] ? p_c[0] : wdata[31:0]; ... endcase|
|p10|assert ( (rst\_ni && rst\_6) \|\| (acct\_mem[0]==32'h0000\_0000))|42|assert -name HACK@DAC21_p42 {((acct_wrapper_i.rst_ni && rst_6) || (acct_wrapper_i.acct_mem.read_data_0[0]==32'h0000_0000))}|always @(posedge clk_i)     begin         if(~(rst_ni && ~rst_6))             begin               for (j=0; j < AcCt_MEM_SIZE; j=j+1) begin                 acct_mem[j] <= 32'hffffffff;                end             end I think the intended behavior is acct_mem[j] <= 32'h0000_0000, wrote the assertion to check that during reset - Jayden|
|p11|assert(debug\_mode\_i \|-> ((key\_big == 192'b0) && (key\_big2 == 192'b0)))|46|assert -name HACK@DAC21_p46 {((aes0_wrapper_i.debug_mode_i) |-> ((aes0_wrapper_i.key_big == 192'b0) && (aes0_wrapper_i.key_big2 == 192'b0)))}|assign key_big0 = debug_mode_i ? 192'b0 : {key0[0], key0[1], key0[2], key0[3], key0[4], key0[5]};  assign key_big1 = debug_mode_i ? 192'b0 : {key1[0], key1[1], key1[2], key1[3], key1[4], key1[5]};  assign key_big2 = {key2[0], key2[1], key2[2], key2[3], key2[4], key2[5]}; ... assign key_big = key_sel[1] ? key_big2 : ( key_sel[0] ? key_big1 : key_big0 ); ...|
|p12|assert(debug\_mode\_i \|-> ((key\_big == 192'b0) && (key\_big2 == 192'b0)))|47|assert -name HACK@DAC21_p47 {((aes0_wrapper_i.debug_mode_i) |-> ((aes0_wrapper_i.key_big == 192'b0) && (aes0_wrapper_i.key_big2 == 192'b0)))}||
|p13|assert(\~(rst\_ni&& \~rst\_9) \|-> \~jtag\_unlock)|48|assert -name HACK@DAC21_p48 {(~(reglk_wrapper_i.rst_ni && ~rst_9) |-> ~reglk_wrapper_i.jtag_unlock)}|always @(posedge clk_i) begin if(~(rst_ni && ~jtag_unlock && ~rst_9)) begin for (j=0; j < 6; j=j+1) begin reglk_mem[j] <= 'h0; end end|
|p14|assert(dma\_ctrl\_reg == CTRL\_ABORT && !done \|=> dma\_ctrl\_reg != CTRL\_ABORT)|57|assert -name HACK@DAC21_p57 {(dma_i.dma_ctrl_reg == dma_i.CTRL_ABORT && !dma_i.done_i |=> dma_i.dma_ctrl_reg != dma_i.CTRL_ABORT)}|        CTRL_ABORT:           begin             if (!done_i)               begin                 dma_ctrl_new = CTRL_ABORT;                  dma_ctrl_en  = 'h0;                end             else|
|p15|assert ((dmi\_req\_ready && state\_q == Write) \|=> (state\_q == WatiWriteValid)).|84|assert -name HACK@DAC21_p84 {((dmi_jtag_i.dmi_req_ready && dmi_jtag_i.state_q == dmi_jtag_i.Write) |=> (dmi_jtag_i.state_q == dmi_jtag_i.WaitWriteValid))}|            Write: begin                 dmi_req_valid = 1'b1;                 // got a valid answer go back to idle                 if (dmi_req_ready) begin                     state_d = Idle;                 end             end              WaitWriteValid: begin                 // just wait for idle here                 if (dmi_resp_valid) begin                     state_d = Idle;                 end             end|
|p16|assert(\~(rst\_ni && \~rst\_13) \|-> (msg\_out == 0))|95|assert -name HACK@DAC21_p95 {(~(rsa_wrapper_i.rst_ni && ~rsa_wrapper_i.rst_13) |-> (rsa_wrapper_i.msg_out == 0))}|        if(~(rst_ni && ~rst_13))             begin                 inter_rst_ni <= 0;                 inter_rst1_ni <= 0;                 encry_decry_i <= 0;                 prime_i <= 1024'b0;                 prime1_i <= 1024'b0;                 msg_in <= 2048'b0;                 //msg_out <= 2048'b0;                                 end|
|p17|assert (ariane\_boot\_sel\_i \|-> rom\_rdata\_patch)|96|assert -name HACK@DAC21_p96_modified {(riscv_peripherals_i.ariane_boot_sel_i |-> riscv_peripherals_i.rom_rdata_linux)}|assign rom_rdata = (ariane_boot_sel_i) ? rom_rdata_linux : rom_rdata_linux;|
|p18|||||
|p19|||||
|p20|||||
